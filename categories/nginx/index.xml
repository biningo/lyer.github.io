<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Nginx - 分类 - lyer's blog</title><link>/categories/nginx/</link><description>Nginx - 分类 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 10 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/nginx/" rel="self" type="application/rss+xml"/><item><title>Nginx总结</title><link>/2021/06/10/nginx%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/06/10/nginx%E6%80%BB%E7%BB%93/</guid><description><![CDATA[Nginx命令 nginx #默认配置启动 nginx -c /etc/nginx.conf #指定配置文件启动 nginx -s reload #重载配置,热重启 kill -s SIGHUB &lt;pid&gt; nginx -s stop #关闭 kill -s SIGINT/SIGTERM &lt;pid&gt; nginx -s quit #优雅关闭 kill -s SIGQUIT &lt;pid&gt;  nginx -s reopen #重新打开日志文件(切割日志) nginx -t #检查默认配置文件语法是否正确 nginx -t -c /etc/nginx.conf #指定配置文件路径 ​
Location匹配规则  寻找精确匹配，匹配成功则返回 精确匹配不成功则匹配非正则的，进行最长匹配(和顺序无关)，如果最长匹配以^~开头则返回 第二步匹配不到则进行正则匹配，正则匹配和配置文件的顺序有关，如果前面的正则匹配成功则会立即返回 正则匹配不成功则继续进行第二步的最长匹配并且返回  匹配的修饰符，对于正则匹配，是一定要加的
^~ 开头匹配 用于不含正则表达式的前缀路径 ~ 大小写敏感 ~* 忽略大小写 ! 反向匹配，！后面可以连接以上的规则 案例一
#访问/a/b/c 返回2 location /a/b/c { return 200 &#34;1&#34;; } location ~ ^/a{ return 200 &#34;2&#34;; } 案例二]]></description></item><item><title>Nginx中server_name和HTTP协议中的Host</title><link>/2021/05/19/nginx%E4%B8%ADserver_name%E5%92%8Chttp%E5%8D%8F%E8%AE%AE%E7%9A%84host/</link><pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/19/nginx%E4%B8%ADserver_name%E5%92%8Chttp%E5%8D%8F%E8%AE%AE%E7%9A%84host/</guid><description><![CDATA[HTTP协议中的Host HTTP请求头部有一个Host字段可以指定目标主机的域名或则主机名，但是最终域名不是需要转化为IP:Port吗？IP:Port不就是可以标识唯一应用了吗？ 那为啥HTTP请求头还需要一个Host字段来标识出域名呢？
这里涉及到 虚拟主机 的概念，即一台主机(一个IP) 可以拥有多个域名，每个域名都可以在80同端口下部署HTTP应用，客户端看访问应用则以为应用是一台独立的主机一样，但是实际上多个应用是共享同一台主机，只不过他们对应的域名不一样罢了，所以也叫虚拟主机
如果一个请求发送到服务器上的80端口，那么监听在80端口上的应用服务器会判断HTTP请求报文中的Host是不是自己的，如果是则接收并且响应，不是则丢弃。或则直接部署一个网关(Nginx)，网关捕获所有请求然后检查HTTP请求头的Host字段根据配置的 Host规则 转发到不同的后端服务器上即可
当然也可以将多个应用分别部署到不同的端口上，只是这样比较麻烦并且占用了端口，有时候还违背了一些默认规则，比如HTTP应用的默认端口80，如果我有两个网站那么我就不得不将其他网站的端口给修改了，这样会造成用户访问不方便
​
一台主机多域名 我们可以配置server_name规则来让Nginx检查Host字段并且转发到相应的服务器上
域名前缀
server { listen 80; server_name www; location / { default_type text/html; content_by_lua &#39; ngx.say(&#34;&lt;p&gt;www&lt;/p&gt;&#34;) &#39;; } } 完整域名
server { listen 80; server_name www.lyer.com; location / { default_type text/html; content_by_lua &#39; ngx.say(&#34;&lt;p&gt;www.lyer.com&lt;/p&gt;&#34;) &#39;; } } 域名正则匹配
server { listen 80; server_name www.lyer.*; location / { default_type text/html; content_by_lua &#39; ngx.say(&#34;&lt;p&gt;www.lyer.*&lt;/p&gt;&#34;) &#39;; } } server { listen 80; server_name ~.]]></description></item></channel></rss>