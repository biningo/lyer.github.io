<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Mon, 23 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>find命令查找文件</title><link>/2021/08/23/find%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</link><pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/23/find%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</guid><description><![CDATA[find命令 find用于在任意的路径下过滤符合条件的文件
​
find基本用法 find后面可以追加多个路径，在多个路径下查找，但是如果不添加路径则表示在命令执行的路径下查找
find &lt;查找路径&gt;... &lt;条件参数&gt;... 列出指定路径下所有的文件
find ~/temp ~/bin ​
按文件名查找 -name
find . -name &#34;*.jpg&#34; #查找以jpg结尾的文件 find . -name &#34;?.jpg&#34; #查找a.jpg这样的文件 find . -name &#34;[abcdef].jpg&#34; #查找a.jpg ... f.jpg -iname 忽略大小写
find -iname &#34;[a-z]*.txt&#34; #a.TXT也可找到 ​
按时间查找 -atime: Access Time
-mtime: Modify Time
-ctime: Change Time
+n n天前 -n n天内
find . -atime -2 #查找2天内被访问过的文件 find . -atime +2 #查找2天前被访问过的文件 -amin 按分钟为单位查找
find . -amin -10 #查找10分钟以内被访问过的 -newer 找出比指定文件修改时间更长的所有文件]]></description></item><item><title>awk工具</title><link>/2021/08/17/awk%E5%B7%A5%E5%85%B7/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/17/awk%E5%B7%A5%E5%85%B7/</guid><description><![CDATA[awk和sed区别 他们都是Linux下的 流处理工具
 awk核心是格式化 sed 核心是 正则  ​
print输出和格式化 BEGIN { username=&#34;lyer&#34; age=18 OFS=&#34;-&#34; #指定print分割符号，默认是\t print &#34;hello,&#34;,&#34;world&#34; print &#34;I&#39;m&#34;,username,age print &#34;a&#34;,&#34;b&#34;,&#34;c&#34; } # -16 不足的往右边填空格 # 16 不足的往左边填空格 { #printf &#34;%-16s %-16s %-16s\n&#34;,$1,$2,$3 printf &#34;%16s %16s %16s\n&#34;,$1,$2,$3 } END{ a = sprintf(&#34;%16s %16s&#34;,&#34;hello&#34;,&#34;world&#34;) print a } ​
NR输出行 输出第1行
awk &#39;NR==1&#39; net.txt 输出[1,4]行
awk &#39;NR==1,NR==4&#39; net.txt awk &#39;NR&gt;=1 &amp;&amp; NR&lt;=4&#39; net.txt 输出行号，$0表示整行数据
awk &#39;NR==1,NR==5 {print NR,$0}&#39; net.txt 范围打印，打印前n行]]></description></item><item><title>iptables总结</title><link>/2021/08/17/iptables%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/17/iptables%E6%80%BB%E7%BB%93/</guid><description>iptables命令格式 iptables命令格式
iptables [-t 表名] 管理选项 [链名] [匹配条件] [-j 控制类型] 不加-t指定表名则默认操作的是filter表 不加指定的链名则会展示表的所有的链规则 ​
四表和五链和数据流向 注意，在OUTPUT之后会通过route表进行路由选择，选择出口的网卡
iptables匹配规则如下，按规则的排列顺序逐一匹配，只要匹配到了就不会再继续往下匹配，就传递给下一个链了，所以我们需要将优先级更高的规则防止在前面
​
查看iptables 查看主要是使用-L命令，表示list的意思
查看nat表的OUTPUT链规则
iptables -t nat -nvL OUTPUT n不解析域名，直接显示IP v显示详细信息 L 表示list展示的意思 一般都会加上-nvL来查看iptables规则
查看filter表的OUTPUT规则
iptables -nvL OUTPUT ​
编写iptables规则 -A命令添加iptables规则
-j后面加控制类型
filter主要有如下控制类型
控制类型 解释 ACCEPT 允许传递数据包 DROP 丢弃数据包，不响应 REJECT 拒绝数据包，响应RST LOG 在/var/log/messages文件中记录日志信息，然后再继续传递 iptables -A INPUT -j DROP #丢弃所有数据包 iptables -A INPUT -j ACCEPT #接受所有数据包 -I表示插入iptables规则，插入到指定的行，原来的行后移</description></item><item><title>Linux静态路由表</title><link>/2021/08/17/linux%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/17/linux%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8/</guid><description>查看路由表 route -n netstat -rn Destination是0.0.0.0表示是默认路由，只有其他路由都匹配不到时才会走这个路由
Gateway为0.0.0.0表示没有网关，静态路由表中的网关只能配置一个，配置多个则只会使用其中一个
​
路由转发流程 工具目标IP个子网掩码匹配静态路由表中的条目 如果匹配到了则将数据包发送到路由表项对应的网卡上 如果路由表项都匹配不成功则走默认路由，也就是Destinaion为0.0.0.0的路由表项，因为默认路由配置了网关所以数据包会从网关发送出去，而在局域网内的通讯则不会走网关 比如我现在要访问172.17.0.10，则会匹配到docker0这个虚拟网桥，然后将数据包转发到docker0中由docker0进行转发
如果我现在要访问192.168.0.10，则会匹配到192.168.0.0这个条目走wlp0s20f3网络接口，这个网络接口是wifi，则会直接发送数据包到wifi猫中，因为是局域网地址所以不会通过网关转发到外网，直接转发到局域网内的目标主机中
如果我现在要访问121.196.169.248，则全部匹配不到会走默认路由，直接转发到网关上然后再转发到外网
​
route命令 route -n route add default gw 10.0.0.1 dev eth0 #指定默认路由 并且设置网关和出口设备 route add -net 10.2.0.0/24 dev eth1 #指定其它路由 route del -net 10.0.0.0/24 #删除路由 ​
参考 掌握Linux路由这一篇就够了！</description></item><item><title>公有云、私有云、混合云</title><link>/2021/08/13/%E5%85%AC%E6%9C%89%E4%BA%91%E7%A7%81%E6%9C%89%E4%BA%91%E6%B7%B7%E5%90%88%E4%BA%91/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/13/%E5%85%AC%E6%9C%89%E4%BA%91%E7%A7%81%E6%9C%89%E4%BA%91%E6%B7%B7%E5%90%88%E4%BA%91/</guid><description>云计算 云计算的目标就是为了让IT服务用起来和水电一样方便，让一些IT基础设施服务按量计费，所租用的计算资源能自动弹性伸缩
​
公有云 公有云就是企业不需要自己管理机房以及维护基础设施，只需要购买云厂商提供的服务即可，云厂商可以提供最优质的基础设施维护和开发。这样企业就不需要自己建立维护IT基础设施服务了，只需要按量付费使用即可。比如遇到双11的场景需要更多的计算资源就可以扩容，如果在平时不需要这么多计算资源就可以缩容以节约成本，通过公有云服务则可以更加方便的扩缩容
有了公有云企业就可以关注自己的业务而不需要关心如何维护IT基础设施比如机房网络这些
​
私有云 私有云就是企业自己有自己的机房、网络等IT基础设施，并且企业自己维护和开发这些IT基础设施，一般大型企业会建立自己的私有云，这样可以保障公司数据的安全。并且可以方便的为公司内部以及子公司等提供统一的云服务
​
混合云 企业自建的云服务可能无法做到很弹性的扩缩容，当业务需要扩张的时候企业的私有云不想再扩容或则没有办法做到立即扩容，比如双11这种活动一年只有一次那么就没必要为那一次而扩容自己的机房，这时候只需要在双11的时候用一下公有云服务即可，这就是混合云
​
巨人肩膀 如何通俗的解释云计算 公有云 私有云 混合云？</description></item><item><title>Linux的Namespace机制</title><link>/2021/08/12/linux%E7%9A%84namespace%E6%9C%BA%E5%88%B6/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/12/linux%E7%9A%84namespace%E6%9C%BA%E5%88%B6/</guid><description>几个重要的Namespace Namespace 系统调用参数 作用 Mount namespaces CLONE_NEWNS 隔离挂载点(隔离文件系统),挂载之后才会生效 UTS namespaces CLONE_NEWUTS 隔离hostname IPC namespaces CLONE_NEWIPC 隔离IPC，只有在同一个Namespace下的进程才能相互通信 PID namespaces CLONE_NEWPID 隔离进程 PID，两个namespace之间pid可以重复 Network namespaces CLONE_NEWNET 隔离网络设备、端口，有独立的协议栈 User namespaces CLONE_NEWUSER 隔离用户和用户组 后面的内核版本又新加入了以下namespace
Namespace 作用 Cgroup namespace 隔离 Cgroups 根目录 Time Namespace 隔离系统时间 ​</description></item><item><title>Linux文件管理</title><link>/2021/08/10/linux%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/10/linux%E6%96%87%E4%BB%B6/</guid><description>文件类型 Linux一切皆文件，很多东西都可以使用VFS抽象为文件来实现
文件类型 符号 举例 普通文件 - 纯文本文件、二进制可执行文件、压缩文件&amp;hellip;. 目录文件 d / socket文件 s / 管道文件 p / 软链接文件 l (L小写) / 查看文件类型的方式主要有下面几个命令
ls -l a.txt file a.txt stat a.txt #查看文件的详细信息 ​
文件时间 文件时间 描述 Access 文件最近被访问的时间 Modify 文件最近被修改的时间，ls -l默认列出的就是修改时间 Change 文件对应的inode节点被改动的时间(chmod、chown) 对于一个首次创建的文件，那么上面三大时间都是一样的</description></item><item><title>为什么栈上内存分配效率高</title><link>/2021/08/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E4%B8%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E9%AB%98/</link><pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E4%B8%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E9%AB%98/</guid><description><![CDATA[栈为什么这么快  栈寄存器的支持
 CPU有专门的栈寄存器 ESP栈顶寄存器，EBP栈基地址寄存器，对于栈内存的访问CPU可以直接根据栈寄存器保存的地址获取到数据
但是堆内存的访问需要先获取到指令然后从指令中获取到堆内存地址保存在寄存器中，最后再通过寄存器的地址进行寻址
 栈空间内存分配和释放比较快
 栈空间在编译时就分配内存给变量了，而堆空间需要程序允许时动态的进行系统调用来分配内存。并且栈在分配内存和释放内存只需要移动栈寄存器的指针即可，所以栈的内存分配和释放都是比较快的
栈空间的管理不需要程序员手动管理，而堆空间需要用户程序手动管理，包括一些GC算法等都是针对堆空间的
 栈适合函数调用场景
 函数调用场景时候用栈这种数据结构，比如
 函数调用结束之后，函数里的局部变量都没用了，则此时应该立即释放其内存 函数嵌套调用  ​
栈的缺点  栈因为结构简单，所以无法应对一些需要动态分配的场景 栈空间需要类型大小是固定，缺乏灵活性  ​
Go的内存逃逸 Go使用new make 等创建的对象不一定都是分配在堆上的，这个和其他语言有点不一样
编译器在编译的时候会进行逃逸分析，可能会将函数内的一些局部变量分配到堆上，逃逸分析的命令如下
go build -gcflags &#39;-m -l&#39; main.go #逃逸分析  函数返回指针，编译器会把变量分配到堆上
 type User struct { Name string } func hello() *User { u := User{Name: &#34;lyer&#34;} return &amp;u }  new一个对象，make一个对象并不一定会分配到堆上
 type User struct { Name string } func hello() { u := new(User) u.]]></description></item><item><title>编程语言自举</title><link>/2021/08/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%87%AA%E4%B8%BE/</link><pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%87%AA%E4%B8%BE/</guid><description>什么是自举 Go1.5完成了自举，也就是说Go现在的编译器就是用Go语言本身写的
编译器也是一个二进制程序，作用就是把语言代码的文本翻译为机器平台对应的二进制可执行文件，机器平台二进制可执行文件可以和汇编语言指令一一对应，每个汇编指令都有其对应的二进制格式的机器码
比如我现在要发明一个E语言，我现在用C语言写一个E语言的编译器然后将这个编译器编译为二进制，这样我们就可以用这个C语言写的E语言编译器去翻译E语言代码了
接着我用E语言实现写了和C语言的那个编译器同样功能的编译器，然后用C编译器编译这个E写的编译器，那么就可以用E写的编译器编译E语言了，这就完成了自举</description></item><item><title>Functional Option模式</title><link>/2021/07/22/functionaloption%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/07/22/functionaloption%E6%A8%A1%E5%BC%8F/</guid><description>当我们创建一个struct时里面有些属性是必须要指定的，但是有些属性是可以有默认值而非必须指定的。比如一个请求HTTP的Client结构体
type Client struct{ Host string Port string Timeout int Protocol string //http https } 其中假如Host和Port是必须指定的，其他两个属性都有默认值，由于go没有函数重载，则需要给每一种情况都创建一个构造函数。为了应对这种可选项，我们就可以使用Functional Option风格
type Client struct { Host string Port uint16 Timeout int Protocol string } type Option func(*Client) func NewClient(host string, port uint16, opts ...Option) *Client { client := &amp;amp;Client{ Host: host, Port: port, Timeout: 10, Protocol: &amp;#34;http&amp;#34;, } for _, o := range opts { o(client) } return client } func WithTimeout(timeout int) Option { return func(client *Client) { client.</description></item></channel></rss>