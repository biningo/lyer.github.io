---
title: 负载均衡算法
date: 2021-09-02
categories: [分布式]
tags: [分布式]
draft: true
---

## 完全随机

完全随机是最简单的负载均衡算法，缺点如下

- 可能造成某台机器压力大，不能保证平均的分摊压力
- 机器的性能有差异，有些机器能处理更多的请求，完全随机不能处理此类场景

下面是Python的实现

```python
def get_ip():
    arr = [
        "192.168.0.10",
        "192.168.0.11",
        "192.168.0.12",
        "192.168.0.13",
        "192.168.0.14",
    ]
    return random.choice(arr)


if __name__ == '__main__':
    for i in range(10):
        print(get_ip())
```

​    

## 加权随机

对于有些性能好的机器我们应该将更多的请求转发给他，也就是设置一个随机的权重

加权随机最容易想到的就是将权重高的IP重复存放，比如我现在有 `A(1) B(7) C(2)` 三个值以及权重，那么我们可以构造出下面的集合

```bash
A B B B B B B B C C
```

然后从里面随机抽取元素，这样重复越多的元素被抽取的权重也就越大。但是这种方法的缺点就是比较耗空间

还有一个连续加减的算法可以改善上面的缺点，并且能达到加权随机的目的

假如有下面4个元素以及权重   `A(2) B(4) C(1) D(3)` 计算出`sum=10`

```bash
1: 1<=2 属于A
2: 2<=2 属于A
3: 3>2 3-2=1<=4 属于B
4: 4>2 4-2=2<=4 属于B
5: 5>2 5-2=3<=4 属于B
6: 6>2 6-2=4<=4 属于B
7: 7>2 7-2=5>4 5-4=1<=1 属于C
8: 8>2 8-2=6>4 6-4=2>1 2-1=1<=3 属于D
9: 9>2 9-2=7>4 7-4=3>1 3-1=2<=3 属于D
10: 10>2 10-2=8>4 8-4=4>1 4-1=3<=3 属于D
```

 可以看到上面数的分布情况，按照这种连续减法的算法可以达到加权随机获取

```python
def get_ip():
    arr = {
        "192.168.0.10": 2,
        "192.168.0.11": 4,
        "192.168.0.12": 1,
        "192.168.0.13": 3,
    }
    s = 0
    for v in arr.values():
        s += v
    r = random.randint(1, s)
    for k, v in arr.items():
        if r <= v:
            return k
        r -= v

#统计测试一下
if __name__ == '__main__':
    m = {}
    for i in range(100):
        ip = get_ip()
        m[ip] = m.get(ip, 0) + 1
    for k, v in m.items():
        print(k, v)
```

​    

## 完全轮询

完全轮询就是一个个轮询而不考虑权重，也是一个最简单的负载均衡策略

```python
class FullRound:
    def __init__(self):
        self.index = 0
        self.arr = [
            "192.168.0.10",
            "192.168.0.11",
            "192.168.0.12",
            "192.168.0.13",
        ]

    def get_ip(self):
        v = self.arr[self.index]
        self.index = (self.index + 1) % len(self.arr)
        return v


if __name__ == '__main__':
    r = FullRound()
    for i in range(10):
        print(r.get_ip())
```

​    

## 加权轮询

加权轮询的思想和**随机加权轮询**思想一样，只不过将随机产生的改为轮询固定的值，下面是实现

```python
class WeightRound:
    def __init__(self):
        self.index = 1
        self.ips = {
            "192.168.0.10": 5,
            "192.168.0.11": 2,
            "192.168.0.12": 2,
            "192.168.0.13": 1,
        }
        self.sum = 0
        for v in self.ips.values():
            self.sum += v

    def get_ip(self):
        r = self.index if self.index > 0 else self.sum
        self.index = ((self.index + 1) % self.sum)  # 防止0的出现
        for k, v in self.ips.items():
            if r <= v:
                return k
            r -= v


if __name__ == '__main__':
    r = WeightRound()
    m = {}
    for i in range(100):
        ip = r.get_ip()
        m[ip] = m.get(ip, 0) + 1
    for k, v in m.items():
        print(k, v)
```

可以看100次实验的结果必定是`5:2:2:1`的精确结果 ，而加权平均则没那么精确，因为毕竟是随机产生的数，而轮询加权的数则是确定固定的

缺点就是分布是固定的，没办法穿插起来，这样会造成一段时间服务器压力升高而请求数过了之后服务器又非常空闲，而随机数会比轮询更加随机穿插起来

​     

## 平滑加权轮询

TODO



## IP哈希

IP哈希就是对客户端的一些信息比如客户端IP做一个hash算法，让指定的客户端请求到指定的服务器上去

这种算法的缺点就是如果hash算法选择不好容易造成hash倾斜，hash函数计算出来的hash值可能都会对应到同一个节点

​        

## 一致性哈希

一致性hash解决的问题就是在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系

​      

## 最小连接

每次选则服务器中活跃的连接数最少的那个进行请求，也就是选择压力最小的服务器请求

​     

## 巨人肩膀

[浅谈负载均衡算法与实现](https://juejin.cn/post/6844903793012768781)

[深入浅出Nginx 负载均衡算法篇](https://huhaipeng.top/2019/10/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E7%AF%87/)

