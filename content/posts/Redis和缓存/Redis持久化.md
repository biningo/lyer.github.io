---
title: Redis持久化
date: 2021-07-30
categories: [Redis]
tags: [Redis]
draft: true
---

## RDB持久化

数据库全量备份，有`save阻塞模式`和`bgsave非阻塞模式`

非阻塞模式会启动一个子进程然后创建RDB文件，Linux创建进程的特性是`copy on write`，所以新创建的子进程相当于拿到了一份创建时的数据快照，父进程还可以继续处理请求但是会重新copy一个内存页去保存新数据这样不会影响到子进程进行RBD快照备份，子进程退出时候会通知父进程然后父进程使用新创建的RBD备份文件替换旧RBD文件

RBD持久化可以手动执行命令进行，也可以配置指定的触发条件自动进行bgsave备份，相关的备份配置

```bash
save 60 1000 #60s内如果执行了1000次key的修改则执行bgsave备份RDB文件
```

如果没有指定redis的持久化方式则默认使用RDB持久化

RDB的缺点:  RDB属于全量备份，创建RDB文件需要扫描整个数据库这样开销会很大，所以不能频繁的做RDB持久化，但是这样就容易丢数据，如果在RDB持久化之前宕机了那么这部分的数据就都丢失了

RDB的优点: 由于RDB文件以二进制格式的方式保存的是数据库的数据，所以在数据恢复的时候速度会很快，直接将数据恢复到内存即可

​    

## AOF持久化

AOF持久化采用追加日志的形式，每次执行完命令就往AOF日志里面追加一条(顺序IO)，在恢复数据的时候就需要执行AOF文件里的命令即可恢复数据，打开AOF持久化则需要在配置文件里加上 `appendonly yes`

AOF文件和操作系统有关，在写入AOF日志的时候操作系统为了减少磁盘IO次数并不会立即写入到磁盘，而是先将数据保存到内核的磁盘IO缓存区，如果我们强制操作系统进行写入磁盘则需要执行 `fsync`系统调用，如果服务器宕机了但是操作系统没有将缓存区里的刷新到磁盘则缓冲区的数据就会丢失，但是如果是redis服务本身挂了则不会丢失数据

为了保障AOF数据不会丢失，我们可以设置`appndfsync`如下即可选项

- always 每次写入AOF日志的时候都调用`fsync`进行刷盘
- everysec 每秒调用一次 `fsync`将AOF指令缓存区里的数据写入到文件并且执行`fsync`进行刷盘
- no 让操作系统自己决定什么时候将缓存区里面的数据刷盘

一般我们选择`everysec`，这样不仅能减少IO次数，而且能保证数据丢失最小化，要是真的宕机了也只是丢失`1s`的数据

```bash
appendfsync everysec
```

> AOF重写

当命令执行很多的时候我们的AOF日志文件就会变得很大，并且在数据库恢复的时候也会造成额外的消耗，并且一些过期了的key则可以删除那条日志，所以此时我们可以讲AOF重写一下减少体积，比如

```bash
lpush arr 1
lpush arr 2
lpush arr 3
```

就可以重写为

```bash
lpush arr 1 2 3
```

AOF重写也是开辟子进程进行重写，这样可以避免锁的消耗，但是重写过程中父进程还在处理命令，于是此时父进程会将所有AOF日志都先保存在AOF重写缓冲区里面，等重写完毕之后再将缓存区里面的AOF日志追加到AOF文件中，然后就会用新的AOF文件替换旧文件

> AOF缺点

- AOF恢复需要执行命令，所以恢复数据速度会很慢
- AOF日志体积比RDB文件大
- AOF重写需要占用资源较大

> AOF优点

- 日志追加方式写日志，效率高可以每执行一条命令则执行日志记录，这样就防止数据丢失

​    

## RDB和AOF混合持久化

结合了RDB和AOF的优点，Redis还支持RDB和AOF混合持久化

混合持久化就是在AOF日志重写的时候写为RDB格式的数据文件，然后后面还会追加AOF日志，也就是说一个文件前半部分包含了RDB格式的数据，后半部分的AOF格式的日志。下次重写时又会将后半部分的AOF日志重写为RDB格式

恢复的时候先恢复前半部分的RDB数据，然后再恢复后半部分的日志数据

