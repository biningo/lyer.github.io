<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - lyer's blog</title><link>/posts/</link><description>所有文章 | lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Fri, 13 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/posts/" rel="self" type="application/rss+xml"/><item><title>公有云、私有云、混合云</title><link>/2021/08/13/%E5%85%AC%E6%9C%89%E4%BA%91%E7%A7%81%E6%9C%89%E4%BA%91%E6%B7%B7%E5%90%88%E4%BA%91/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/13/%E5%85%AC%E6%9C%89%E4%BA%91%E7%A7%81%E6%9C%89%E4%BA%91%E6%B7%B7%E5%90%88%E4%BA%91/</guid><description>云计算 云计算的目标就是为了让IT服务用起来和水电一样方便，让一些IT基础设施服务按量计费，所租用的计算资源能自动弹性伸缩
​
公有云 公有云就是企业不需要自己管理机房以及维护基础设施，只需要购买云厂商提供的服务即可，云厂商可以提供最优质的基础设施维护和开发。这样企业就不需要自己建立维护IT基础设施服务了，只需要按量付费使用即可。比如遇到双11的场景需要更多的计算资源就可以扩容，如果在平时不需要这么多计算资源就可以缩容以节约成本，通过公有云服务则可以更加方便的扩缩容
有了公有云企业就可以关注自己的业务而不需要关心如何维护IT基础设施比如机房网络这些
​
私有云 私有云就是企业自己有自己的机房、网络等IT基础设施，并且企业自己维护和开发这些IT基础设施，一般大型企业会建立自己的私有云，这样可以保障公司数据的安全。并且可以方便的为公司内部以及子公司等提供统一的云服务
​
混合云 企业自建的云服务可能无法做到很弹性的扩缩容，当业务需要扩张的时候企业的私有云不想再扩容或则没有办法做到立即扩容，比如双11这种活动一年只有一次那么就没必要为那一次而扩容自己的机房，这时候只需要在双11的时候用一下公有云服务即可，这就是混合云
​
巨人肩膀 如何通俗的解释云计算 公有云 私有云 混合云？</description></item><item><title>Linux的Namespace机制</title><link>/2021/08/12/linux%E7%9A%84namespace%E6%9C%BA%E5%88%B6/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/12/linux%E7%9A%84namespace%E6%9C%BA%E5%88%B6/</guid><description>几个重要的Namespace Namespace 系统调用参数 作用 Mount namespaces CLONE_NEWNS 隔离挂载点(隔离文件系统),挂载之后才会生效 UTS namespaces CLONE_NEWUTS 隔离hostname IPC namespaces CLONE_NEWIPC 隔离IPC，只有在同一个Namespace下的进程才能相互通信 PID namespaces CLONE_NEWPID 隔离进程 PID，两个namespace之间pid可以重复 Network namespaces CLONE_NEWNET 隔离网络设备、端口，有独立的协议栈 User namespaces CLONE_NEWUSER 隔离用户和用户组 后面的内核版本又新加入了以下namespace
Namespace 作用 Cgroup namespace 隔离 Cgroups 根目录 Time Namespace 隔离系统时间 ​</description></item><item><title>Linux文件管理</title><link>/2021/08/10/linux%E6%96%87%E4%BB%B6/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/10/linux%E6%96%87%E4%BB%B6/</guid><description>文件类型 Linux一切皆文件，很多东西都可以使用VFS抽象为文件来实现
文件类型 符号 举例 普通文件 - 纯文本文件、二进制可执行文件、压缩文件&amp;hellip;. 目录文件 d / socket文件 s / 管道文件 p / 软链接文件 l (L小写) / 查看文件类型的方式主要有下面几个命令
ls -l a.txt file a.txt stat a.txt #查看文件的详细信息 ​
文件时间 文件时间 描述 Access 文件最近被访问的时间 Modify 文件最近被修改的时间，ls -l默认列出的就是修改时间 Change 文件对应的inode节点被改动的时间(chmod、chown) 对于一个首次创建的文件，那么上面三大时间都是一样的</description></item><item><title>为什么栈上内存分配效率高</title><link>/2021/08/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E4%B8%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E9%AB%98/</link><pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E4%B8%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E9%AB%98/</guid><description><![CDATA[栈为什么这么快  栈寄存器的支持
 CPU有专门的栈寄存器 ESP栈顶寄存器，EBP栈基地址寄存器，对于栈内存的访问CPU可以直接根据栈寄存器保存的地址获取到数据
但是堆内存的访问需要先获取到指令然后从指令中获取到堆内存地址保存在寄存器中，最后再通过寄存器的地址进行寻址
 栈空间内存分配和释放比较快
 栈空间在编译时就分配内存给变量了，而堆空间需要程序允许时动态的进行系统调用来分配内存。并且栈在分配内存和释放内存只需要移动栈寄存器的指针即可，所以栈的内存分配和释放都是比较快的
栈空间的管理不需要程序员手动管理，而堆空间需要用户程序手动管理，包括一些GC算法等都是针对堆空间的
 栈适合函数调用场景
 函数调用场景时候用栈这种数据结构，比如
 函数调用结束之后，函数里的局部变量都没用了，则此时应该立即释放其内存 函数嵌套调用  ​
栈的缺点  栈因为结构简单，所以无法应对一些需要动态分配的场景 栈空间需要类型大小是固定，缺乏灵活性  ​
Go的内存逃逸 Go使用new make 等创建的对象不一定都是分配在堆上的，这个和其他语言有点不一样
编译器在编译的时候会进行逃逸分析，可能会将函数内的一些局部变量分配到堆上，逃逸分析的命令如下
go build -gcflags &#39;-m -l&#39; main.go #逃逸分析  函数返回指针，编译器会把变量分配到堆上
 type User struct { Name string } func hello() *User { u := User{Name: &#34;lyer&#34;} return &amp;u }  new一个对象，make一个对象并不一定会分配到堆上
 type User struct { Name string } func hello() { u := new(User) u.]]></description></item><item><title>编程语言自举</title><link>/2021/08/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%87%AA%E4%B8%BE/</link><pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/08/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%87%AA%E4%B8%BE/</guid><description>什么是自举 Go1.5完成了自举，也就是说Go现在的编译器就是用Go语言本身写的
编译器也是一个二进制程序，作用就是把语言代码的文本翻译为机器平台对应的二进制可执行文件，机器平台二进制可执行文件可以和汇编语言指令一一对应，每个汇编指令都有其对应的二进制格式的机器码
比如我现在要发明一个E语言，我现在用C语言写一个E语言的编译器然后将这个编译器编译为二进制，这样我们就可以用这个C语言写的E语言编译器去翻译E语言代码了
接着我用E语言实现写了和C语言的那个编译器同样功能的编译器，然后用C编译器编译这个E写的编译器，那么就可以用E写的编译器编译E语言了，这就完成了自举</description></item><item><title>Functional Option模式</title><link>/2021/07/22/functionaloption%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/07/22/functionaloption%E6%A8%A1%E5%BC%8F/</guid><description>当我们创建一个struct时里面有些属性是必须要指定的，但是有些属性是可以有默认值而非必须指定的。比如一个请求HTTP的Client结构体
type Client struct{ Host string Port string Timeout int Protocol string //http https } 其中假如Host和Port是必须指定的，其他两个属性都有默认值，由于go没有函数重载，则需要给每一种情况都创建一个构造函数。为了应对这种可选项，我们就可以使用Functional Option风格
type Client struct { Host string Port uint16 Timeout int Protocol string } type Option func(*Client) func NewClient(host string, port uint16, opts ...Option) *Client { client := &amp;amp;Client{ Host: host, Port: port, Timeout: 10, Protocol: &amp;#34;http&amp;#34;, } for _, o := range opts { o(client) } return client } func WithTimeout(timeout int) Option { return func(client *Client) { client.</description></item><item><title>Nginx导论</title><link>/2021/06/10/nginx%E5%AF%BC%E8%AE%BA/</link><pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/06/10/nginx%E5%AF%BC%E8%AE%BA/</guid><description><![CDATA[Nginx命令 nginx #默认配置启动 nginx -c /etc/nginx.conf #指定配置文件启动 nginx -s reload #重载配置,热重启 kill -s SIGHUB &lt;pid&gt; nginx -s stop #关闭 kill -s SIGINT/SIGTERM &lt;pid&gt; nginx -s quit #优雅关闭 kill -s SIGQUIT &lt;pid&gt;  nginx -s reopen #重新打开日志文件(切割日志) nginx -t #检查默认配置文件语法是否正确 nginx -t -c /etc/nginx.conf #指定配置文件路径 ​
Location匹配规则  寻找精确匹配，匹配成功则返回 精确匹配不成功则匹配非正则的，进行最长匹配(和顺序无关)，如果最长匹配以^~开头则返回 第二步匹配不到则进行正则匹配，正则匹配和配置文件的顺序有关，如果前面的正则匹配成功则会立即返回 正则匹配不成功则继续进行第二步的最长匹配并且返回  匹配的修饰符，对于正则匹配，是一定要加的
^~ 开头匹配 用于不含正则表达式的前缀路径 ~ 大小写敏感 ~* 忽略大小写 ! 反向匹配，！后面可以连接以上的规则 案例一
#访问/a/b/c 返回2 location /a/b/c { return 200 &#34;1&#34;; } location ~ ^/a{ return 200 &#34;2&#34;; } 案例二]]></description></item><item><title>容器网络原理</title><link>/2021/06/10/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/06/10/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/</guid><description>概览 bridge 虚拟网桥模式 host 宿主机共享模式 none 无网络模式 container 容器共享模式 ​
bridge网桥模式 docker网络使用Linux提供的veth pair和virtual bridge技术来实现网桥模式
在该模式下每个容器都有一个独立的局域网虚拟IP，通讯范围如下:
跨网段的两个容器即使是在同一台宿主机上也不可以互通 （为什么？） 容器和宿主机可以互通 容器可以连接外界网络，外界网络连接容器的服务需要进行端口映射 创建虚拟网桥
docker network create -d bridge --subnet 192.168.25.0/24 --gateway 192.168.25.1 mynetwork 创建容器，指定网络
docker run -d --name pingip --net mynetwork biningo/pingip 如果想让外网访问容器的服务，可以指定端口映射，这样外网直接访问宿主机的端口就可以访问容器的服务了
docker run -d --name pingip --net mynetwork -p 8080:9090 biningo/pingip docker-proxy进程负责进行内网穿透，物理网卡上对应映射端口的流量会转发到docker-proxy进程上，然后docker-proxy再转发到容器内，容器内响应数据包也见过docker-proxy进行转发到物理网卡对应的端口中
如果容器想要访问外网则必须进过iptables的NAT网络地址转换才可以访问外网
在自定义的网络中是可以直接通过容器名进行访问的，而在docker0网络下则只能通过IP进行访问同网段的主机
​
host宿主机共享模式 docker run --name busybox -it --net host busybox:1.32.0 sh 进入容器执行ifconfig命令可以看到和宿主机上的网络一模一样，容器没有自己的IP，外界直接访问宿主机即可访问容器的服务</description></item><item><title>打包一个最小的Go镜像</title><link>/2021/06/10/%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84go%E9%95%9C%E5%83%8F/</link><pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/06/10/%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84go%E9%95%9C%E5%83%8F/</guid><description><![CDATA[此Dockerfile来源: https://github.com/new-go/port-scan
 FROMgolang:1.16-alpine3.13 as builder ENV GOPROXY=https://goproxy.ioWORKDIR/buildADD . /build/RUN CGO_ENABLED=0 go build -a -ldflags &#34;-s -w&#34; -o pscan /build/FROMscratchCOPY --from=builder /build/pscan /ENTRYPOINT [&#34;/pscan&#34;]CGO_ENABLED=0表示不使用cgo，可以编译为一个纯静态的二进制文件，这样就不需要依赖其他动态加载库了，方便部署到Docker中
-ldflags表示链接的一些参数，-s 的作用是去掉符号信息，-w的作用是去掉调试信息，这样可以最大程度减少镜像的体积
-a 强制重新构建]]></description></item><item><title>git三大区域和远程仓库</title><link>/2021/06/05/git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link><pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/06/05/git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid><description><![CDATA[git三大区域 ​
工作区 工作区就是我们的本地目录
​
暂存区 暂存区用于暂时存放我们工作区域的更改，比如我们工作区域修改了一个文件，此时就可以先放入暂存区
然后我继续修改这个文件&hellip;&hellip;
改完之后我突然觉得文件这样修改不是很好，还是原来的比较好，想要恢复回原来的样子，此时暂存区就发挥作用了
我们可以将暂存区域的文件覆盖回工作区域，这样就又回到上次暂存的样子了，恢复之后此时暂存区的内容又和工作区域一致了
git add a.txt git restore a.txt #将上次暂存的文件覆盖到工作区 git restore --staged a.txt #取消暂存 也就是清空暂存区 ​
本地仓库 如果确保此次修改就是最终版本，那么我们可以将暂存区域中的内容提交到本地仓库。此时暂存区的内容就被提交为一个版本，暂存区中的内容也会被清空
一次提交就相当于一次版本的发布，所有人都可以看到此版本所做的变更，并且以后可以回退到此版本
git commit a.txt -m &#34;new a&#34; git reset --hard HEAD^ #回退 git reset a112c #回退到特定的版本号 ​
三大区域变更 暂存区-&gt;工作区
git restore #将暂存区文件恢复到工作区 git restore --staged #取消暂存 git rm #直接删除暂存区和本地文件 git mv #同时修改暂存区和工作区的文件 版本库-&gt;工作区
#将工作区代码回滚到指定版本,此时暂存区内容也会清空 git reset &lt;版本号&gt; #可以通过HEAD来指定 HEAD表示当前版本 HEAD^上一个版本 HEAD^^上上个版本.... git reset --hard HEAD git reset --hard HEAD^ #~指定版本 假设v1 v2 v3 v4 v5 则现在HEAD在v5 命令之后:HEAD=v3 git reset --hard HEAD~2 #可以所有的版本号 以便回到过去还可以回到将来 git reflog ​]]></description></item></channel></rss>